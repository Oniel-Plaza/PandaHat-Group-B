# Exploiting a Smart Plug.

## Step 1 - Reverse Engineering the apk

The tool we used for reversing the plug's application binary was JADx by sky-Iot. The command for downloading this tool is the following:  
```  
jadx-gui homemate.apk  
```  
We then had to navigate to ***SecurityAes.java*** located in ***homateap.orbivo.com.securitylibrary*** package. In here, we found multiple methods 
relating to the application's security. The actual code for these methods was stored in the native library ***libHomeMate_Security.so*** and it was 
located whithin both ***lib/armeabi*** and ***lib/x86*** directories. To find these, we extracted the application binary by using:  
```  
$ unzip HomeMate.apk -d homemate  
$ cd homemate/lib/armeabi/  
$ 1s libHomeMate_Security.so  
```  
## Step 2 - Disassembling Functions with Binary Ninja's Cloud Version  

We used Binary Ninja's Cloud Version to start reverse engineering the extracted file we obtained from the previous step. Binary Ninja provided us with 
a list of functions that were contained inside this file, but we only need to analyze the one called ***Java_homateap_orvibo_com_securitylibrary_SecurityAes_encryptByteKey***.
Using Binary Ninja's *disassembly* on this function gave us access to the code and information stored inside it. Once inside, we had to look for an *add* 
operation that was associated with the variable **pkKey@GOT**. We then cliked on this variable so that it could take us to its definition. Once we were 
there, we looked for the identifier **pkKey** and extracted its memory address associated to it, which, in our case, was 0000655c. After getting the address
we enabled the *Strings view* in Binary Ninja to allow us to see the encryption key stored in that memory address.

## Step 3 - Intercepting Network Traffic

After optaining the encryption key, we had to intercept the traffic to and from the smart plug in order to optain: key, commands to turn off and turn on the smart plug, the session id and see exactly how the server is communicating with the smart plug. For this we set up a router using our laptop. This router needs to have connection to the internet. In our case, to set up the router we simply
toggled the option on the network settings. After that is done we connect the plug to the router we made in order to capture the
packets using wireshark.
We use Wireshark to capture the traffic using the filter: `data $$ eth.addr==2c:3a:e8:12:2c:31` or simply `data $$ eth.addr==deviceMACAddress`.
After capturing the packets we filtered for the most recent ones to find the first packets since we are going to need them in order to get the key provided by the server. Since the only part of the packets captured that concerns us is the packet body, we select that part of the packet and copy as hexstream for later use.

## Step 4 - Decrypting pacakage from Wireshark

The script used to decrypt the data dec.py use Python 3 and the PyCryptoDome library. In order to use the script a virtual environment must be set. 
``` 
from Crypto.Cipher import AES

aeskey = "khggd54865SNJHGF"
wiresharkpacket = bytes.fromhex("Insert Hex Stream")
aesobj = AES.new(aeskey.encode(), AES.MODE_ECB)
decrypted = aesobj.decrypt(wiresharkpacket[42:])
print(decrypted.decode())

print(str(aesobj.decrypt(wiresharkpacket[42:])))
``` 

The script above beigns by importing the AES module from the Crypto.Cipher Library. Then, using the AES key retreived from reversing the smart plug's application: `khggd54865SNJHGF`. This key is definec as a sgring and the Wireshark packet in form of hexadcimal. Netx, an AES object is created using AES.new() function with key and mode operation (ECB) specified. Then, the decrypted data is obtained by calling and decrypt() function on the AES abject, passing in the portyion of the Wireshark packting starting at the 42nd byte. The first 42 bytes contain header information. Finally, the decryted data is printed as a string using the decode() function ande print statement is modified to use te decode funtion to print the decrypted data as a string. 


## Step 5 - Controlling the Smart Plug 

The plug only responds to commands from the homemate server. For this reason, the creation of a proxy is needed. This will not only realy the packets to-and-fro between the socket and the server buut also able to inject our own messages. First, we must ensure that the injected message is encrypted similarly as the socket expeccts. The socket replies to both commands received from the server and those injected by the proxy relay. The replies that corresponds to the injected commands must be dropped and must not reach the server. 

Redirecting traffic using IPTables 

```
# iptables -t nat -A PREROUTING -i wlan0 -p tcp -d proxy address --dport 10001 -j REDIRECT --to-port 8080
```

The purpose of the proxy relay is to transparently forward the messages between the Orvibo soocket and the server while also giving us the avilabity to inject our own commands. The proxy relay tool aslo set up a web server to allow us to turn OFF/ON the socket using the web browser. 





